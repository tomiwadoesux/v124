"use client";

import { useEffect, useRef } from 'react';

/**
 * DITHERED GRADIENT WITH EMBEDDED IMAGE
 * -------------------------------------
 * Generated by Dither.Tool
 * If there is an Error with the speed, remove the extra '.0' from the number in the CONFIG section.
 * * Gradient Style: Wavy
 * Dither Style:   Bayer
 */

// --- CONFIGURATION ---
const CONFIG = {
  gradientStyle: 0, 
  ditherStyle: 0,   
  ditherSize: 1.0,
  speed: 0.9,
  colors: ['#0a0a0a', '#f5f5f5'],
  imageOpacity: 0.3,
  imageScale: 1.15
};

// --- EMBEDDED ASSET ---
// We use JSON.stringify to safely quote the string or output 'null'
const EMBEDDED_IMAGE = "data:image/webp;base64,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";

// --- SHADERS ---
// (Injected from the working preview code)
const vertexShader = `
  attribute vec2 position;
  void main() {
    gl_Position = vec4(position, 0.0, 1.0);
  }
`;

const fragmentShader = `
  precision highp float;
  
  uniform vec2 uResolution;
  uniform float uTime;
  uniform float uSpeed;
  uniform int uGradientStyle;
  uniform int uDitherStyle;
  uniform float uDitherSize;
  uniform int uColorCount;
  uniform vec3 uColors[8];
  
  // Image uniforms
  uniform sampler2D uImage;
  uniform vec2 uImageResolution;
  uniform float uImageOpacity;
  uniform float uImageScale;
  uniform bool uHasImage;
  
  // Bayer 8x8 matrix
  float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    float bayer[64];
    bayer[0] = 0.0; bayer[1] = 32.0; bayer[2] = 8.0; bayer[3] = 40.0; bayer[4] = 2.0; bayer[5] = 34.0; bayer[6] = 10.0; bayer[7] = 42.0;
    bayer[8] = 48.0; bayer[9] = 16.0; bayer[10] = 56.0; bayer[11] = 24.0; bayer[12] = 50.0; bayer[13] = 18.0; bayer[14] = 58.0; bayer[15] = 26.0;
    bayer[16] = 12.0; bayer[17] = 44.0; bayer[18] = 4.0; bayer[19] = 36.0; bayer[20] = 14.0; bayer[21] = 46.0; bayer[22] = 6.0; bayer[23] = 38.0;
    bayer[24] = 60.0; bayer[25] = 28.0; bayer[26] = 52.0; bayer[27] = 20.0; bayer[28] = 62.0; bayer[29] = 30.0; bayer[30] = 54.0; bayer[31] = 22.0;
    bayer[32] = 3.0; bayer[33] = 35.0; bayer[34] = 11.0; bayer[35] = 43.0; bayer[36] = 1.0; bayer[37] = 33.0; bayer[38] = 9.0; bayer[39] = 41.0;
    bayer[40] = 51.0; bayer[41] = 19.0; bayer[42] = 59.0; bayer[43] = 27.0; bayer[44] = 49.0; bayer[45] = 17.0; bayer[46] = 57.0; bayer[47] = 25.0;
    bayer[48] = 15.0; bayer[49] = 47.0; bayer[50] = 7.0; bayer[51] = 39.0; bayer[52] = 13.0; bayer[53] = 45.0; bayer[54] = 5.0; bayer[55] = 37.0;
    bayer[56] = 63.0; bayer[57] = 31.0; bayer[58] = 55.0; bayer[59] = 23.0; bayer[60] = 61.0; bayer[61] = 29.0; bayer[62] = 53.0; bayer[63] = 21.0;
    for (int i = 0; i < 64; i++) { if (i == index) return bayer[i] / 64.0; }
    return 0.0;
  }
  
  float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
  float blueNoise(vec2 pos) { float n = 0.0; n += hash(pos) * 0.5; n += hash(pos * 2.0 + 100.0) * 0.25; n += hash(pos * 4.0 + 200.0) * 0.125; return fract(n * 2.0); }
  float halftone(vec2 pos, float value) { vec2 center = floor(pos) + 0.5; float dist = length(pos - center); float radius = sqrt(value) * 0.7; return step(dist, radius); }
  float linePattern(vec2 pos, float angle) { float c = cos(angle); float s = sin(angle); vec2 rotated = vec2(pos.x * c - pos.y * s, pos.x * s + pos.y * c); return fract(rotated.x); }
  float bayer4x4(vec2 pos) { int x = int(mod(pos.x, 4.0)); int y = int(mod(pos.y, 4.0)); int index = x + y * 4; float bayer[16]; bayer[0]=0.0; bayer[1]=8.0; bayer[2]=2.0; bayer[3]=10.0; bayer[4]=12.0; bayer[5]=4.0; bayer[6]=14.0; bayer[7]=6.0; bayer[8]=3.0; bayer[9]=11.0; bayer[10]=1.0; bayer[11]=9.0; bayer[12]=15.0; bayer[13]=7.0; bayer[14]=13.0; bayer[15]=5.0; for (int i = 0; i < 16; i++) { if (i == index) return bayer[i] / 16.0; } return 0.0; }
  float ign(vec2 pos) { return fract(52.9829189 * fract(0.06711056 * pos.x + 0.00583715 * pos.y)); }
  float rings(vec2 pos) { vec2 center = floor(pos) + 0.5; return fract(length(pos - center) * 2.0); }
  
  // Gradient Functions
  float wavyGradient(vec2 uv, float time) { float v = 0.0; v += sin(uv.x * 4.0 + time) * 0.3; v += cos(uv.y * 3.0 - time * 0.7) * 0.3; v += sin((uv.x + uv.y) * 5.0 + time * 1.3) * 0.2; v += cos(uv.x * 2.0 - uv.y * 3.0 + time * 0.5) * 0.2; return v * 0.5 + 0.5; }
  float radialGradient(vec2 uv, float time) { vec2 center = vec2(0.5 + sin(time * 0.5) * 0.2, 0.5 + cos(time * 0.3) * 0.2); float dist = length(uv - center); return sin(dist * 8.0 - time * 2.0) * 0.5 + 0.5; }
  float diagonalGradient(vec2 uv, float time) { float angle = time * 0.2; float c = cos(angle); float s = sin(angle); vec2 rotated = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c); return sin(rotated.x * 6.0 + rotated.y * 2.0 + time) * 0.5 + 0.5; }
  float noiseGradient(vec2 uv, float time) { vec2 p = uv * 3.0; float n = 0.0; n += sin(p.x + time) * cos(p.y + time * 0.7); n += sin(p.x * 2.1 - time * 0.8) * cos(p.y * 1.9 + time * 0.6) * 0.5; n += sin(p.x * 3.3 + time * 1.1) * cos(p.y * 2.8 - time * 0.9) * 0.25; return n * 0.3 + 0.5; }
  float plasmaGradient(vec2 uv, float time) { float v = 0.0; v += sin(uv.x * 10.0 + time); v += sin(uv.y * 10.0 + time * 1.2); v += sin((uv.x + uv.y) * 10.0 + time * 1.5); v += sin(sqrt(uv.x * uv.x + uv.y * uv.y) * 10.0 + time); return v * 0.125 + 0.5; }
  float spiralGradient(vec2 uv, float time) { vec2 center = vec2(0.5, 0.5); vec2 pos = uv - center; float r = length(pos); float a = atan(pos.y, pos.x); return sin(r * 20.0 + a * 3.0 - time * 3.0) * 0.5 + 0.5; }
  float squareGradient(vec2 uv, float time) { vec2 center = vec2(0.5, 0.5); vec2 pos = abs(uv - center); float d = max(pos.x, pos.y); return sin(d * 15.0 - time * 2.0) * 0.5 + 0.5; }
  float zigzagGradient(vec2 uv, float time) { vec2 pos = uv * 5.0; float v = pos.y + sin(pos.x * 2.0 + time) * 0.5; return sin(v * 4.0 + time) * 0.5 + 0.5; }
  float swirlGradient(vec2 uv, float time) { vec2 center = vec2(0.5, 0.5); vec2 pos = uv - center; float len = length(pos); float ang = atan(pos.y, pos.x); ang += len * 8.0 - time; return sin(ang * 4.0) * 0.5 + 0.5; }
  float auroraGradient(vec2 uv, float time) { float v = 0.0; v += sin(uv.x * 3.0 + time * 0.5) * 0.5; v += sin(uv.x * 5.0 + uv.y * 2.0 + time * 0.8) * 0.3; v += sin(uv.x * 8.0 - time * 0.3) * 0.2; float y = uv.y + sin(uv.x * 2.0 + time) * 0.1; return sin(y * 5.0 + v * 5.0) * 0.5 + 0.5; }
  
  // UV Cover Logic
  vec2 getCoverUV(vec2 uv, vec2 screenRes, vec2 imgRes) {
    float screenAspect = screenRes.x / screenRes.y;
    float imgAspect = imgRes.x / imgRes.y;
    
    vec2 scale = vec2(1.0);
    
    if (screenAspect > imgAspect) {
      scale = vec2(1.0, imgAspect / screenAspect);
    } else {
      scale = vec2(screenAspect / imgAspect, 1.0);
    }
    
    return (uv - 0.5) * scale + 0.5;
  }

  void main() {
    vec2 uv = gl_FragCoord.xy / uResolution;
    float time = uTime * uSpeed;
    
    // 1. GENERATE GRADIENT
    float gradient = 0.0;
    if (uGradientStyle == 0) gradient = wavyGradient(uv, time);
    else if (uGradientStyle == 1) gradient = radialGradient(uv, time);
    else if (uGradientStyle == 2) gradient = diagonalGradient(uv, time);
    else if (uGradientStyle == 3) gradient = noiseGradient(uv, time);
    else if (uGradientStyle == 4) gradient = plasmaGradient(uv, time);
    else if (uGradientStyle == 5) gradient = spiralGradient(uv, time);
    else if (uGradientStyle == 6) gradient = squareGradient(uv, time);
    else if (uGradientStyle == 7) gradient = zigzagGradient(uv, time);
    else if (uGradientStyle == 8) gradient = swirlGradient(uv, time);
    else if (uGradientStyle == 9) gradient = auroraGradient(uv, time);
    
    gradient = clamp(gradient, 0.0, 1.0);

    // 2. APPLY IMAGE BLEND IF PRESENT
    if (uHasImage) {
        vec2 baseUV = getCoverUV(uv, uResolution, uImageResolution);
        // Apply scale relative to center (0.5)
        vec2 imgUV = (baseUV - 0.5) / uImageScale + 0.5;
        
        if (imgUV.x >= 0.0 && imgUV.x <= 1.0 && imgUV.y >= 0.0 && imgUV.y <= 1.0) {
           vec4 imgColor = texture2D(uImage, imgUV);
           float luminance = dot(imgColor.rgb, vec3(0.299, 0.587, 0.114));
           float structure = smoothstep(0.0, 1.0, luminance); 
           float blended = gradient * structure;
           gradient = mix(gradient, blended * 1.5, uImageOpacity);
        }
    }
    
    // 3. DITHERING
    vec2 ditherPos = gl_FragCoord.xy / uDitherSize;
    float threshold = 0.0;
    if (uDitherStyle == 0) threshold = bayer8x8(ditherPos);
    else if (uDitherStyle == 1) threshold = blueNoise(ditherPos);
    else if (uDitherStyle == 2) threshold = halftone(ditherPos, gradient);
    else if (uDitherStyle == 3) threshold = linePattern(ditherPos, 0.785);
    else if (uDitherStyle == 4) threshold = hash(floor(ditherPos));
    else if (uDitherStyle == 5) threshold = bayer4x4(ditherPos);
    else if (uDitherStyle == 6) threshold = ign(ditherPos);
    else if (uDitherStyle == 7) threshold = rings(ditherPos);
    
    // 4. COLOR MAPPING
    float scaledGradient = gradient * float(uColorCount - 1);
    int colorIndex = int(floor(scaledGradient));
    float localGradient = fract(scaledGradient);
    
    int nextIndex = colorIndex + 1;
    if (nextIndex >= uColorCount) nextIndex = uColorCount - 1;
    
    vec3 color1 = uColors[0];
    vec3 color2 = uColors[0];
    
    for (int i = 0; i < 8; i++) {
      if (i == colorIndex) color1 = uColors[i];
      if (i == nextIndex) color2 = uColors[i];
    }
    
    vec3 finalColor;
    if (uDitherStyle == 2) {
      finalColor = mix(color1, color2, threshold);
    } else {
      finalColor = localGradient > threshold ? color2 : color1;
    }
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

// --- UTILS ---
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [ parseInt(result[1], 16)/255, parseInt(result[2], 16)/255, parseInt(result[3], 16)/255 ] : [0, 0, 0];
}

export default function DitheredGradientPage() {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const startTimeRef = useRef(Date.now());
  const textureRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const gl = canvas.getContext('webgl');
    if (!gl) return;
    
    // Create shaders
    const createShader = (type, source) => {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader Compile Error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    };

    const vs = createShader(gl.VERTEX_SHADER, vertexShader);
    const fs = createShader(gl.FRAGMENT_SHADER, fragmentShader);
    if (!vs || !fs) return;

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program Link Error:', gl.getProgramInfoLog(program));
        return;
    }
    
    gl.useProgram(program);

    // Fullscreen quad
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    const position = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    // Texture Setup
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    // Init with 1x1 transparent pixel
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,0]));
    textureRef.current = texture;

    // Load EMBEDDED Image if exists
    let imgAspect = { w: 1, h: 1 };
    let hasImage = false;
    
    if (EMBEDDED_IMAGE) {
        const img = new Image();
        img.onload = () => {
            imgAspect = { w: img.width, h: img.height };
            hasImage = true;
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        };
        img.src = EMBEDDED_IMAGE;
    }

    // Resize
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    };
    window.addEventListener('resize', resize);
    resize();

    // Render
    const render = () => {
      const time = (Date.now() - startTimeRef.current) / 1000;
      gl.useProgram(program);
      
      gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), gl.canvas.width, gl.canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
      gl.uniform1f(gl.getUniformLocation(program, 'uSpeed'), CONFIG.speed);
      gl.uniform1i(gl.getUniformLocation(program, 'uGradientStyle'), CONFIG.gradientStyle);
      gl.uniform1i(gl.getUniformLocation(program, 'uDitherStyle'), CONFIG.ditherStyle);
      gl.uniform1f(gl.getUniformLocation(program, 'uDitherSize'), CONFIG.ditherSize);
      gl.uniform1i(gl.getUniformLocation(program, 'uColorCount'), CONFIG.colors.length);

      // Image Uniforms
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, textureRef.current);
      gl.uniform1i(gl.getUniformLocation(program, 'uImage'), 0);
      gl.uniform1i(gl.getUniformLocation(program, 'uHasImage'), hasImage);
      gl.uniform2f(gl.getUniformLocation(program, 'uImageResolution'), imgAspect.w, imgAspect.h);
      gl.uniform1f(gl.getUniformLocation(program, 'uImageOpacity'), CONFIG.imageOpacity);
      gl.uniform1f(gl.getUniformLocation(program, 'uImageScale'), CONFIG.imageScale);

      const colorArray = [];
      for (let i = 0; i < 8; i++) {
        const hex = CONFIG.colors[i] || CONFIG.colors[CONFIG.colors.length - 1];
        colorArray.push(...hexToRgb(hex));
      }
      gl.uniform3fv(gl.getUniformLocation(program, 'uColors'), colorArray);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      animationRef.current = requestAnimationFrame(render);
    };
    render();

    return () => {
      window.removeEventListener('resize', resize);
      cancelAnimationFrame(animationRef.current);
    };
  }, []);

  return (
    <main className="w-full h-screen bg-black absolute overflow-hidden">
      <canvas ref={canvasRef} className="block w-full h-full" />
    </main>
  );
}
